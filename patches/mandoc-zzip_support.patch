diff -Naur a/read.c b/read.c
--- a/read.c	2019-03-10 06:56:43.000000000 -0300
+++ b/read.c	2019-06-07 20:51:30.483486597 -0300
@@ -53,6 +53,7 @@
 	const char	 *os_s; /* default operating system */
 	int		  options; /* parser options */
 	int		  gzip; /* current input file is gzipped */
+	int		  zzip; /* current input file is zzipped */
 	int		  filenc; /* encoding of the current file */
 	int		  reparse_count; /* finite interp. stack */
 	int		  line; /* line number in the file */
@@ -423,10 +424,13 @@
 read_whole_file(struct mparse *curp, int fd, struct buf *fb, int *with_mmap)
 {
 	struct stat	 st;
+	z_stream	 strm;
 	gzFile		 gz;
 	size_t		 off;
 	ssize_t		 ssz;
-	int		 gzerrnum, retval;
+	ssize_t		 zsz;
+	int		 gzerrnum, retval, zerr;
+	Bytef		 *zbuf;
 
 	if (fstat(fd, &st) == -1) {
 		mandoc_msg(MANDOCERR_FILE, 0, 0,
@@ -441,7 +445,7 @@
 	 * concerned that this is going to tank any machines.
 	 */
 
-	if (curp->gzip == 0 && S_ISREG(st.st_mode)) {
+	if (curp->gzip == 0 && curp->zzip == 0 && S_ISREG(st.st_mode)) {
 		if (st.st_size > 0x7fffffff) {
 			mandoc_msg(MANDOCERR_TOOLARGE, 0, 0, NULL);
 			return 0;
@@ -472,6 +476,15 @@
 			close(fd);
 			return 0;
 		}
+	} else if (curp->zzip) {
+		memset(&strm, 0, sizeof(strm));
+		if (inflateInit(&strm) < 0) {
+			errno = ENOMEM;
+			mandoc_msg(MANDOCERR_FILE, 0, 0,
+			    "inflateInit: %s", strerror(errno));
+			return 0;
+		}
+		zbuf = mandoc_malloc(65536);
 	} else
 		gz = NULL;
 
@@ -493,9 +506,33 @@
 			}
 			resize_buf(fb, 65536);
 		}
-		ssz = curp->gzip ?
-		    gzread(gz, fb->buf + (int)off, fb->sz - off) :
-		    read(fd, fb->buf + (int)off, fb->sz - off);
+		if (curp->gzip) {
+			ssz = gzread(gz, fb->buf + (int)off, fb->sz - off);
+		} else if (curp->zzip) {
+			ssz = 0;
+			zsz = read(fd, zbuf, 65536);
+			strm.avail_in = (unsigned)zsz;
+			strm.next_in  = zbuf;
+			do {
+				strm.avail_out = fb->sz  - off;
+				strm.next_out  = (Bytef *)fb->buf + (int)off;
+				switch (zerr = inflate(&strm, Z_NO_FLUSH)) {
+				case Z_STREAM_ERROR:
+				case Z_NEED_DICT:
+				case Z_DATA_ERROR:
+				case Z_MEM_ERROR:
+					mandoc_msg(MANDOCERR_FILE, 0, 0,
+					    "inflate: %s",
+					    "invalid or incomplete deflate data"
+					    );
+					ssz = -1;
+					break;
+				}
+				ssz += (fb->sz - off) - strm.avail_out;
+			} while (!strm.avail_out);
+		} else {
+			ssz = read(fd, fb->buf + (int)off, fb->sz - off);
+		}
 		if (ssz == 0) {
 			fb->sz = off;
 			retval = 1;
@@ -516,6 +553,11 @@
 		mandoc_msg(MANDOCERR_FILE, 0, 0, "gzclose: %s",
 		    gzerrnum == Z_ERRNO ? strerror(errno) :
 		    zError(gzerrnum));
+	if (curp->zzip) {
+		inflateEnd(&strm);
+		free(zbuf);
+		zbuf = NULL;
+	}
 	if (retval == 0) {
 		free(fb->buf);
 		fb->buf = NULL;
@@ -611,6 +653,7 @@
 
 	cp = strrchr(file, '.');
 	curp->gzip = (cp != NULL && ! strcmp(cp + 1, "gz"));
+	curp->zzip = (cp != NULL && ! strcmp(cp + 1, "zz"));
 
 	/* First try to use the filename as it is. */
 
@@ -633,6 +676,18 @@
 			return fd;
 		}
 	}
+
+	if ( ! curp->zzip) {
+		save_errno = errno;
+		mandoc_asprintf(&cp, "%s.zz", file);
+		fd = open(cp, O_RDONLY);
+		free(cp);
+		errno = save_errno;
+		if (fd != -1) {
+			curp->zzip = 1;
+			return fd;
+		}
+	}
 
 	/* Neither worked, give up. */
 
